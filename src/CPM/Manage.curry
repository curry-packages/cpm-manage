------------------------------------------------------------------------------
--- This module implements tools to manage the central repository:
---
--- Run "cpm-manage -h" to see all options.
---
------------------------------------------------------------------------------

module CPM.Manage ( main )
  where

import Directory ( createDirectoryIfMissing, doesDirectoryExist, doesFileExist
                 , getAbsolutePath, getCurrentDirectory )
import FilePath  ( (</>), replaceExtension )
import IOExts    ( evalCmd )
import List      ( groupBy, nub, sortBy, sum )
import System    ( getArgs, exitWith, system )
import Time      ( getLocalTime, toDayString )

import HTML.Base
import ShowDotGraph
import Text.CSV     ( writeCSVFile )

import CPM.Config          ( Config, repositoryDir, packageInstallDir
                           , readConfigurationWith )
import CPM.ErrorLogger
import CPM.FileUtil        ( copyDirectory, inDirectory, tempDir
                           , recreateDirectory
                           , removeDirectoryComplete )
import CPM.Package
import CPM.PackageCache.Global ( acquireAndInstallPackageFromSource
                               , checkoutPackage )
import CPM.Package.Helpers     ( renderPackageInfo )
import CPM.Repository          ( allPackages, listPackages
                               , readPackageFromRepository )
import CPM.Repository.Update   ( addPackageToRepository, updateRepository )
import CPM.Repository.Select   ( getBaseRepository )
import CPM.Resolution          ( isCompatibleToCompiler )

------------------------------------------------------------------------------
-- Some global settings:

--- Base URL of CPM documentations
cpmDocURL :: String
cpmDocURL = "https://www-ps.informatik.uni-kiel.de/~cpm/DOC/"

--- Subdirectory of `CpmDocDir` containing HTML files for each package
--- generated by `cpm-manage genhtml`.
packageHtmlDir :: String
packageHtmlDir = "HTML"

--- The default directory containing all package documentations
--- generated by `cypm doc`.
packageDocDir :: String
packageDocDir = "CPM" </> "DOC"

--- The default directory containing tar files of all packages.
packageTarDir :: String
packageTarDir = "CPM" </> "PACKAGES"

--- Directory with documentations for Currygle.
currygleDocDir :: String
currygleDocDir = "currygledocs"

------------------------------------------------------------------------------
main :: IO ()
main = do
  args <- getArgs
  case args of
    ["genhtml"]     -> writePackageIndexAsHTML "CPM"
    ["genhtml",d]   -> writePackageIndexAsHTML d
    ["gendocs"]     -> generateDocsOfAllPackages packageDocDir
    ["gendocs",d]   -> getAbsolutePath d >>= generateDocsOfAllPackages
    ["gentar"]      -> genTarOfAllPackages packageTarDir
    ["gentar",d]    -> getAbsolutePath d >>= genTarOfAllPackages
    ["testall"]     -> testAllPackages
    ["add"]         -> addNewPackage True
    ["addnotag"]    -> addNewPackage False
    ["update"]      -> updatePackage
    ["showgraph"]   -> showAllPackageDependencies
    ["writedeps"]   -> writeAllPackageDependencies
    ["copydocs"]    -> copyPackageDocumentations packageDocDir
    ["copydocs",d]  -> getAbsolutePath d >>= copyPackageDocumentations
    ["--help"]      -> getHelpText >>= putStrLn
    ["-h"]          -> getHelpText >>= putStrLn
    _               -> do putStrLn $ "Wrong arguments!\n"
                          getHelpText >>= putStrLn
                          exitWith 1

getHelpText :: IO String
getHelpText = do
  return $ unlines $
    [ "Options:", ""
    , "add           : add this package version to the central repository"
    , "                and tag git repository of this package with its version"
    , "addnotag      : add this package version to the central repository"
    , "                (do not tag git repository)"
    , "update        : tag git repository of local package with current version"
    , "                and update central index with current package specification"
    , "genhtml [<d>] : generate HTML pages of central repository into <d>"
    , "                (default: 'CPM')"
    , "gendocs [<d>] : generate HTML documentations of all packages into <d>"
    , "                (default: '" ++ packageDocDir ++ "')"
    , "gentar  [<d>] : generate tar.gz files of all packages into <d>"
    , "                (default: '" ++ packageTarDir ++ "')"
    , "testall       : test all packages of the central repository"
    , "showgraph     : visualize all package dependencies as dot graph"
    , "writedeps     : write all package dependencies as CSV file 'pkgs.csv'"
    , "copydocs [<d>]: copy latest package documentations"
    , "                from <d> (default: '" ++ packageDocDir ++ "')"
    , "                to '" ++ currygleDocDir ++ "'"
    ]

------------------------------------------------------------------------------
--- Get all packages from the repository.
--- For each package, get the newest version compatible
--- to the current compiler. If there is no compatible version and the
--- first argument is False, get the newest version, otherwise the package
--- is ignored.
--- In addition to this package list (third component),
--- the first component contains the current configuration and the
--- second component the list of all packages grouped by versions
--- (independent of the compiler compatbility).
getAllPackageSpecs :: Bool -> IO (Config,[[Package]],[Package])
getAllPackageSpecs compat = do
  config <- readConfiguration
  putStrLn "Reading base repository..."
  repo <- getBaseRepository config
  let allpkgversions = listPackages repo
      allcompatpkgs  = sortBy (\ps1 ps2 -> name ps1 <= name ps2)
                              (concatMap (filterCompatPkgs config)
                                         allpkgversions)
  return (config,allpkgversions,allcompatpkgs)
 where
  -- Returns the first package compatible to the current compiler.
  -- If `compat` is False and there are no compatible packages,
  -- return the first package.
  filterCompatPkgs cfg pkgs =
    let comppkgs = filter (isCompatibleToCompiler cfg) pkgs
    in if null comppkgs
         then if compat then [] else take 1 pkgs
         else [head comppkgs]

------------------------------------------------------------------------------
-- Generate web index pages of the CPM repository.
writePackageIndexAsHTML :: String -> IO ()
writePackageIndexAsHTML cpmindexdir = do
  createDirectoryIfMissing True cpmindexdir
  inDirectory cpmindexdir $ do
   createDirectoryIfMissing True packageHtmlDir
   system $ "chmod 755 " ++ packageHtmlDir
   (config,allpkgversions,newestpkgs) <- getAllPackageSpecs False
   putStrLn "Reading all package specifications..."
   allpkgs <- mapIO (fromErrorLogger . readPackageFromRepository config)
                    newestpkgs
   let indexfile = "index.html"
   ltime <- getLocalTime
   putStrLn $ "Writing '" ++ indexfile ++ "'..."
   writeReadableFile indexfile $ showHtmlPage $
     cpmHtmlPage "Curry Packages in the CPM Repository" $
       [h1 [htxt "Curry Packages in the ",
            href "http://www.curry-lang.org/tools/cpm" [htxt "CPM"]
              `addAttr` ("target","_blank"),
            htxt $ " Repository (" ++ toDayString ltime ++ ")"],
        packageInfosAsHtmlTable allpkgs] ++
        pkgStatistics allpkgversions newestpkgs
   mapIO_ writePackageAsHTML allpkgs
 where
  pkgStatistics allpkgversions newestpkgs =
    [h4 [htxt "Statistics:"],
     par [htxt $ show (length newestpkgs) ++ " packages", breakline,
          htxt $ show (length (concat allpkgversions)) ++ " package versions"]]
         
  writePackageAsHTML pkg = do
    let pname    = name pkg
        pkgid    = packageId pkg
        htmlfile = packageHtmlDir </> pkgid ++ ".html"
        readmefile = "DOC" </> pkgid </> "README.html"
    hasreadme <- doesFileExist readmefile
    putStrLn $ "Writing '" ++ htmlfile ++ "'..."
    let pkginfo = renderPackageInfo True True True pkg
        manref  = manualRef pkg False
    writeReadableFile htmlfile $ showHtmlPage $
      cpmTitledHtmlPage ("Curry Package '" ++ pname ++ "'") $
        (if hasreadme
           then [blockstyle "reference"
                   [href --(cpmDocURL ++ pkgid </> "README.html")
                         ("../" ++ readmefile)
                         [htxt "README"] `addClass` "arrow"]]
           else []) ++
        [blockstyle "reference" $ apiRef pkg False] ++
        (if null manref then [] else [blockstyle "reference" manref]) ++
        [blockstyle "metadata"
           [h3 [htxt "Package metadata:"],
            verbatim pkginfo]]

--- Writes a file readable for all:
writeReadableFile :: String -> String -> IO ()
writeReadableFile f s = writeFile f s >> system ("chmod 644 " ++ f) >> done

--- API reference of a package:
apiRef :: Package -> Bool -> [HtmlExp]
apiRef pkg small =
 let title       = if small then "API" else "API documentation"
     addArrow he = if small then he else addClass he "arrow"
 in [addArrow $ href (cpmDocURL ++ packageId pkg) [htxt title]]

--- Manual reference of a package:
manualRef :: Package -> Bool -> [HtmlExp]
manualRef pkg small =
 let title       = if small then "PDF" else "Manual (PDF)"
     addArrow he = if small then he else addClass he "arrow"
 in case documentation pkg of
      Nothing -> []
      Just (PackageDocumentation _ docmain _) ->
        [addArrow $ href (cpmDocURL ++ packageId pkg </>
                          replaceExtension docmain ".pdf")
                         [htxt title]]

-- Format a list of packages as an HTML table
packageInfosAsHtmlTable :: [Package] -> HtmlExp
packageInfosAsHtmlTable pkgs =
  headedTable $
    [map ((:[]) . htxt)
         ["Name", "API", "Doc","Executable","Synopsis", "Version"] ] ++
    map formatPkg pkgs
 where
  formatPkg pkg =
    [ [href (packageHtmlDir </> packageId pkg ++ ".html") [htxt $ name pkg]]
    , apiRef pkg True
    , let manref = manualRef pkg True
      in if null manref then [nbsp] else manref
    , [htxt $ maybe ""
                    (\ (PackageExecutable n _ _) -> n)
                    (executableSpec pkg)]
    , [htxt $ synopsis pkg]
    , [htxt $ showVersion (version pkg)] ]

--- Standard HTML page with a title for CPM generated docs.
cpmHtmlPage :: String -> [HtmlExp] -> HtmlPage
cpmHtmlPage title hexps =
  page title hexps `addPageParam` pageCSS "css/cpm.css"

--- Standard HTML page with a title (included in the body)
--- for CPM generated docs:
cpmTitledHtmlPage :: String -> [HtmlExp] -> HtmlPage
cpmTitledHtmlPage title hexps = cpmHtmlPage title (h1 [htxt title] : hexps)

------------------------------------------------------------------------------
-- Generate HTML documentation of all packages in the central repository
generateDocsOfAllPackages :: String -> IO ()
generateDocsOfAllPackages packagedocdir = do
  (_,_,allpkgs) <- getAllPackageSpecs True
  mapIO_ genDocOfPackage allpkgs
 where
  genDocOfPackage pkg = inEmptyTempDir $ do
    let pname = name pkg
        pversion = showVersion (version pkg)
    putStrLn $ unlines [dline, "Documenting: " ++ pname, dline]
    let cmd = unwords [ "rm -rf", pname, "&&"
                      , "cypm","checkout", pname, pversion, "&&"
                      , "cd", pname, "&&"
                      , "cypm", "install", "--noexec", "&&"
                      , "cypm", "doc", "--docdir", packagedocdir
                              , "--url", cpmDocURL, "&&"
                      , "cd ..", "&&"
                      , "rm -rf", pname
                      ]
    putStrLn $ "CMD: " ++ cmd
    system cmd

------------------------------------------------------------------------------
-- Run `cypm test` on all packages of the central repository
testAllPackages :: IO ()
testAllPackages = do
  (_,_,allpkgs) <- getAllPackageSpecs True
  results <- mapIO checkoutAndTestPackage allpkgs
  if sum (map fst results) == 0
    then putStrLn $ show (length allpkgs) ++ " PACKAGES SUCCESSFULLY TESTED!"
    else do putStrLn $ "ERRORS OCCURRED IN PACKAGES: " ++
                       unwords (map snd (filter ((> 0) . fst) results))
            exitWith 1

dline :: String
dline = take 78 (repeat '=')

------------------------------------------------------------------------------
-- Generate tar.gz files of all packages (in the current directory)
genTarOfAllPackages :: String -> IO ()
genTarOfAllPackages tardir = do
  createDirectoryIfMissing True tardir
  putStrLn $ "Generating tar.gz of all package versions in '" ++ tardir ++
             "'..."
  (cfg,allpkgversions,_) <- getAllPackageSpecs False
  allpkgs <- mapIO (fromErrorLogger . readPackageFromRepository cfg)
                   (sortBy (\ps1 ps2 -> packageId ps1 <= packageId ps2)
                           (concat allpkgversions))
  mapIO_ (writePackageAsTar cfg) allpkgs --(take 3 allpkgs)
 where
  writePackageAsTar cfg pkg = do
    let pkgname  = name pkg
        pkgid    = packageId pkg
        tarfile  = tardir </> pkgid ++ ".tar.gz"
    putStrLn $ "Checking out '" ++ pkgid ++ "'..."
    let checkoutdir = pkgname
    system $ unwords [ "rm -rf", checkoutdir ]
    fromErrorLogger
      (acquireAndInstallPackageFromSource cfg pkg |> checkoutPackage cfg pkg)
    let cmd = unwords [ "cd", checkoutdir, "&&"
                      , "tar", "cvzf", tarfile, ".", "&&"
                      , "chmod", "644", tarfile, "&&"
                      , "cd", "..", "&&", "rm", "-rf", checkoutdir
                      ]
    putStrLn $ "...with command:\n" ++ cmd
    ecode <- system cmd
    when (ecode>0) $ error $ "ERROR OCCURED IN PACKAGE '" ++ pkgid ++ "'!"


------------------------------------------------------------------------------
-- Add a new package (already committed and pushed into its git repo)
-- where the package specification is stored in the current directory.
addNewPackage :: Bool -> IO ()
addNewPackage withtag = do
  config <- readConfiguration
  pkg <- fromErrorLogger (loadPackageSpec ".")
  when withtag $ setTagInGit pkg
  let pkgIndexDir      = name pkg </> showVersion (version pkg)
      pkgRepositoryDir = repositoryDir config </> pkgIndexDir
      pkgInstallDir    = packageInstallDir config </> packageId pkg
  fromErrorLogger $ addPackageToRepository config "." False False
  putStrLn $ "Package repository directory '" ++ pkgRepositoryDir ++ "' added."
  (ecode,_) <- checkoutAndTestPackage pkg
  when (ecode>0) $ do
    removeDirectoryComplete pkgRepositoryDir
    removeDirectoryComplete pkgInstallDir
    putStrLn "Checkout/test failure, package deleted in repository directory!"
    updateRepository config True True False
    exitWith 1
  putStrLn $ "\nEverything looks fine..."
  putStrLn $ "\nTo publish the new repository directory, run command:\n"
  putStrLn $ "pushd " ++ repositoryDir config ++
             " && git add " ++ pkgIndexDir </> packageSpecFile ++
             " && git commit -m\"" ++ pkgIndexDir ++ " added\" " ++
             " && git push origin master && popd"

-- Test a specific version of a package by checking it out in temp dir,
-- install it (with a local bin dir), and run all tests.
-- Returns the exit code of the package test command and the packaged id.
checkoutAndTestPackage :: Package -> IO (Int,String)
checkoutAndTestPackage pkg = inEmptyTempDir $ do
  let pkgname     = name pkg
      pkgversion  = version pkg
      pkgid       = packageId pkg
  putStrLn $ unlines [dline, "Testing package: " ++ pkgid, dline]
  -- create installation bin dir:
  curdir <- getCurrentDirectory
  let bindir = curdir </> "pkgbin"
  recreateDirectory bindir
  let checkoutdir = pkgname
      cmd = unwords
              [ "rm -rf", checkoutdir, "&&"
              , "cypm", "checkout", pkgname, showVersion pkgversion, "&&"
              , "cd", checkoutdir, "&&"
              -- install possible binaries in bindir:
              , "cypm", "-d bin_install_path=" ++ bindir, "install", "&&"
              , "export PATH=" ++ bindir ++ ":$PATH", "&&"
              , "cypm", "test", "&&"
              , "cypm", "-d bin_install_path=" ++ bindir, "uninstall"
              ]
  putStrLn $ "...with command:\n" ++ cmd
  ecode <- system cmd
  when (ecode>0) $ putStrLn $ "ERROR OCCURED IN PACKAGE '" ++ pkgid ++ "'!"
  return (ecode,pkgid)

-- Set the package version as a tag in the git repository.
setTagInGit :: Package -> IO ()
setTagInGit pkg = do
  let ts = 'v' : showVersion (version pkg)
  (_,gittag,_) <- evalCmd "git" ["tag","-l",ts] ""
  let deltag = if null gittag then [] else ["git tag -d",ts,"&&"]
      cmd    = unwords $ deltag ++ ["git tag -a",ts,"-m",ts,"&&",
                                    "git push --tags -f"]
  putStrLn $ "Execute: " ++ cmd
  ecode <- system cmd
  when (ecode > 0) $ error "ERROR in setting the git tag"

------------------------------------------------------------------------------
-- Re-tag the current git version with the current package version
-- and copy the package spec file to the cpm index
updatePackage :: IO ()
updatePackage = do
  config <- readConfiguration
  pkg <- fromErrorLogger (loadPackageSpec ".")
  let pkgInstallDir    = packageInstallDir config </> packageId pkg
  setTagInGit pkg
  putStrLn $ "Deleting old repo copy '" ++ pkgInstallDir ++ "'..."
  removeDirectoryComplete pkgInstallDir
  (ecode,_) <- checkoutAndTestPackage pkg
  when (ecode > 0) $ do removeDirectoryComplete pkgInstallDir
                        putStrLn $ "ERROR in package, CPM index not updated!"
                        exitWith 1
  fromErrorLogger $ addPackageToRepository config "." True False

------------------------------------------------------------------------------
-- Show package dependencies as dot graph
showAllPackageDependencies :: IO ()
showAllPackageDependencies = do
  config <- readConfiguration
  pkgs <- getBaseRepository config >>= return . allPackages
  let alldeps = map (\p -> (name p, map (\ (Dependency p' _) -> p')
                                        (dependencies p)))
                    pkgs
      dotgraph = depsToGraph alldeps
  putStrLn $ "Show dot graph..."
  viewDotGraph dotgraph

depsToGraph :: [(String, [String])] -> DotGraph
depsToGraph cpmdeps =
  dgraph "CPM Dependencies"
    (map (\s -> Node s []) (nub (map fst cpmdeps ++ concatMap snd cpmdeps)))
    (map (\ (s,t) -> Edge s t [])
         (nub (concatMap (\ (p,ds) -> map (\d -> (p,d)) ds) cpmdeps)))

-- Write package dependencies into CSV file 'pkgs.csv'
writeAllPackageDependencies :: IO ()
writeAllPackageDependencies = do
  (_,_,pkgs) <- getAllPackageSpecs True
  let alldeps = map (\p -> (name p, map (\ (Dependency p' _) -> p')
                                        (dependencies p)))
                    pkgs
  writeCSVFile "pkgs.csv" (map (\ (p,ds) -> p:ds) alldeps)
  putStrLn $ "Package dependencies written to 'pkgs.csv'"

------------------------------------------------------------------------------
-- Copy all package documentations from directory `packagedocdir` into
-- the directory `currygleDocDir` so that the documentations
-- can be used by Currygle to generate the documentation index
copyPackageDocumentations :: String -> IO ()
copyPackageDocumentations packagedocdir = do
  config <- readConfiguration
  allpkgs <- getBaseRepository config >>= return . allPackages
  let pkgs   = map sortVersions (groupBy (\a b -> name a == name b) allpkgs)
      pkgids = sortBy (\xs ys -> head xs <= head ys) (map (map packageId) pkgs)
  putStrLn $ "Number of package documentations: " ++ show (length pkgs)
  recreateDirectory currygleDocDir
  mapIO_ copyPackageDoc pkgids
 where
  sortVersions ps = sortBy (\a b -> version a `vgt` version b) ps

  copyPackageDoc [] = done
  copyPackageDoc (pid:pids) = do
    let pdir = packagedocdir </> pid
    exdoc <- doesDirectoryExist pdir
    if exdoc
      then do putStrLn $ "Copying documentation of " ++ pid ++ "..."
              copyDirectory pdir (currygleDocDir </> pid)
      else
        if null pids
          then putStrLn $ "Documentation " ++ pid ++ " does not exist!"
          else copyPackageDoc pids

------------------------------------------------------------------------------
--- Reads to the .cpmrc file from the user's home directory and return
--- the configuration. Terminate in case of some errors.
readConfiguration :: IO Config
readConfiguration =
  readConfigurationWith [] >>= \c -> case c of
    Left err -> do putStrLn $ "Error reading .cpmrc file: " ++ err
                   exitWith 1
    Right c' -> return c'

--- Executes an IO action with the current directory set to a new empty
--- temporary directory. After the execution, the temporary directory
--- is deleted.
inEmptyTempDir :: IO a -> IO a
inEmptyTempDir a = do
  tmp <- tempDir
  recreateDirectory tmp
  r  <- inDirectory tmp a
  removeDirectoryComplete tmp
  return r

------------------------------------------------------------------------------
-- The name of the package specification file.
packageSpecFile :: String
packageSpecFile = "package.json"

------------------------------------------------------------------------------
